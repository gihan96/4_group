10.4 포인터와 문자열
* 포인터를 이용한 문자열 선언방법
-> ex) char* p = "MOON" 이 있다 고 할 떄, 포인터 p의 각 주소 스택에 , p = 'M', p+1 = 'O', p+2 = 'O', p+3 = 'O', p+4 = '\0' 순으로 쌓인다. 

-> 예제 10 - 9. 포인터를 이용하여 문자열 출력하기
#include <stdio.h>

int main(void)
{
	char* pC = "C programing";
	printf("문자열을 변환 기호를 이용하여 출력\n");
	printf("%s\n", pC);

	printf("반복문을 이용해 한 글자씩 출력\n");
	while (*pC)
		printf("%c", *pC++);
	printf("\n");

	return 0;
} 
위의 예제를 보면 while(*pC)는 *(pC + 0)부터 *pC의 주소에 저장된 모든 값이 출력될 때 까지 만든다. 그 후  printf("%c", *pC++);를 통해 *pC + 0 부터 시작해서 다음 글자가 하나씩 출럭된다.
그래서 결과를 보면 위의 "문자열을 변환 기호를 이용하여 출력"과 마찬가지로 "C programing"이 출력된다.

*배열 포인터 
-> 문자열을 동시에 여러개 만들어야 할 경우
ex). char* pStr[3] = {"english, "math", "korean"}이 있다고 가정할 때, 이 때 pStr[0] = 'e', pStr[1] = 'm', pStr[2] = 'k' 문자열 포인터로, 즉 각 문자열의 첫번째 주소를 가리킨다.
-> 이 때 불필요한 메모리 낭비를 막기위해 char* pStr[]처럼 배열의 크기를 초기에 지정하지 않아도 된다.
-> 만약 2차원 배열, 예를들어 char* Str[][8] = {"english", "math", "korean"} 식으로 문자열을 동시에 선언할 경우 문자가 가장 많은 "english"가 문자열의 기준이 되기 때문에, "math"나 "korean"의 경우 문자열의 크기가 적음에도 붏구하고,
"english"와 동일한 크기의 메모리를 가지기 때문에, 메모리의 낭비가 발생한다.

-> 예제 10 - 10. 포인터 배열을 이용하여 문자열 출력하기 프로그램
