01. 포인터의 기본
-> 포인터는 변수의 주소값을 가리키는데 사용된다. 예를들어 int a = 10이 있을 떄, a의 주소가 100번지 라고 할 때, 기존의 경우 int b = a라고 하면 a의 값을 가리키는 것이었다.
   즉 b를 출력하고자 하면 b = a = 10, a의 변수값 10이 출력되는 식이다.
   그런데 포인터를 이용하면 포인터 b = a라고 하면 이때 b는 a의 주소 즉 100번지에 있는 값 10을 찾아서 출력하는 것이다.

-> 포인터의 선언방법
  : 자료형* 변수명
  예). int* ptr
-> * 연산자가 하나이면 1차원 포인터를 의미한다.
-> 1차원 포인터는 일반 변수의 주소를 값으로 가진다.

-> 포인터의 예
  : int i = 3;
    int* ptr = &i; 
-> 일반 변수의 주소는 &를 이용하여 표현한다.

-> 포인터의 변수의 크기는 char, int, double 등의 변수의 크기와 관계없이 4바이트로 일정하다.
-> 참고로 배열은 포인터 상수이다.

-> 예제 10-1. 포인터의 기본
#include <stdio.h>

int main(void)
{
	int i = 10;
	int* ptr = &i;

	printf("ptr의 주소 값 : %p\n", &ptr);  //ptr의 주소의 값이 출력된다.
	printf("i의 주소 값 : %p\n", &i);        // i의 주소의 값이 출력된다.
	printf("i의 주소값 : %p\n", ptr);       // ptr이 가리키는 i의 주소의 값이 출력된다.

	printf("i의 값 : %d\n", i);               // i의 값 10이 출력된다.
	printf("i의 값 : %d\n", *ptr);         // ptr이 가리키는 i의 주소에 있는 값 10이 출력된다.
	return 0;
}

-> 포인터를 이용한 연산 
  : 포인터를 이용하여 포인터가 가리키는 곳의 값을 바꾸거나 연산도 가능하다.
  예). int i = 3
       int *p = &i
       *p = i + 5 
      => i의 값이 8로 바뀌게 된다.

-> 예제 10-2. 포인터를 이용한 연산
#include <stdio.h>

int main(void)
{
	int i = 10;
	int* ptr = &i;

	*ptr = i + 20;                         // i의 주소를 가리키는 곳에 20을 더한다.(i = 30)
	printf("i의 값 : %d\n", i);        // i의 값 30이 출력된다.

	i = i + 20;                             // i의 값에 20을 더한다.(i = 50)
	printf("i의 값 : %d\n", *ptr);  // i주소에 있는 값 50이 출력된다.
	return 0;
}

-> 예제 10-3. 포인터를 이용하지 않고 두 수 바꾸기
#include <stdio.h>

void Swap(int a, int b);
int main(void)
{
	int x = 10, y = 5;
	printf("Swap() 함수 실행 전\n");
	printf("x = %d, y = %d이다.\n", x, y);

	Swap(x, y);
	printf("Swap() 함수 실행 후\n");
	printf("x = %d, y = %d이다.\n", x, y);

	return 0;
}

void Swap(int a, int b)
{
	int temp;
	temp = a;
	a = b; 
	b = temp;
}
어떠한 두 개의 정수의 값을 서로 바꾸는 함수 Swap()를 만들어 실행하고자 한다.
이때의 결과를 실행하면 Swap()함수 실행 전과 마찬가지로 x = 10, y = 5가 출력된다. 즉 Swap()함수를 실행했음에도 불구하고 실제 값은 바뀌지 않고 출력됬다.
원래대로라면 값이 바뀌어 x = 5, y = 10가 되어야하는데, 그렇게 되지 않는 이유는 다음과 같다.
  1). 우선 main()함수의 x, y와 Swap()함수의 a, b는 각각의 함수에서만 사용되어지는 변수이다. 그러다 보니 Swap()함수에 main()함수에 있는 x, y값을 대입해도,
  Swap()함수에 있는 변수의 값만 바뀌게 되고, main()함수에 있는 변수 x, y의 값은 변하지 않은 상태가 된다.
  2). void Swap(int a, int b)
     {
	int temp;
	temp = a;
	a = b; 
	b = temp;
     }
     main()함수에서 Swap(x, y)를 실행하게 되면, Swap()함수에서는 다음과 같이 된다.
     _____________________
     |  Swap()함수의 스택 | 
     |___________________|
   b |      5 -> 10      |
     |___________________|
   a |      10 -> 5      |
     |___________________|
temp |        10         |
     |___________________|
     |                   |
     |___________________|
    위와 같은 형태로 Swap()함수라는 스택에 temp = a, a = b, b = temp 순으로 쌓이게 된다.
    그리고 마지막 문장을 수행 후 return 하면서 스택에 쌓인 값은 지워지게 된다. 즉 Swap()함수가 끝난 상태가 되는 것이다.
    그 후 main()함수에서 Swap()함수를 호출해도, Swap()함수는 이미 끝난 상태이기 때문에 아무것도 남아있지 않는다. 
    그렇기 때문에 main()에서 Swap(x, y)함수를 실행해도 x, y의 값이 바뀌지 않는 것이다.

-> 위와 같은 문제를 해결하기 위해서는 Swap(int a, int b) 함수에서 변수 x, y가 아닌 x, y의 주소값을 넘겨주어야 한다.
   즉 포인터를 사용해서 해결할 수 있다.

-> 예제 10-4. 포인터를 이용하여 두 수 구하기
#include <stdio.h>

void Swap(int* a, int* b);
int main(void)
{
	int x = 10, y = 5;
	printf("Swap() 함수 실행 전\n");
	printf("x = %d, y = %d이다.\n", x, y);

	Swap(&x, &y);
	printf("Swap() 함수 실행 후\n");
	printf("x = %d, y = %d이다.\n", x, y);

	return 0;
}

void Swap(int* a, int* b)
{
	int temp;
	temp = *a;
	*a = *b; 
	*b = temp;
}
여기서 main()함수에서 사용되고 있는 Swap(&x, &y)함수의 경우 포인터 변수 a, b가  x, y의 주소값을 가리키고 있다. 그래서 swap()함수를 실행할 경우, x, y의 주소가 전달되는 것이므로,
swap()함수를 끝마친 후 x, y의 값을 출력했을 때는 Swap()함수에서 바뀌어진 값, x = 5, y = 10이 출력된다.

02. 인자 전달 방법
-> 인자: 어떤 사물의 원인이 되는 낱낱의 요소나 물질을 말한다.

-> 인자를 값으로 전달(call of value)
  1). C 언어의 대표적인 인자 전달 방식이다.
  2). 함수가 호출되면 인자 값을 스택(stack)에 복사한다.
  3). 값을 복사하기 때문에 함수에서 인자 값을 바꾸더라도 main( ) 함수는 영향을 받지 않는다. 따라서 두 함수는 독립적으로 작동한다.
-> 인자를 주소로 전달(call of reference)
  1). 전달하려는 변수의 주소를 함수에 전달한다.
  2). 함수에 변수 자체를 전달해야 할 때 사용한다. 
  3). 주소 연산자(&)를 이용하여 변수의 주소 값을 함수에 넘겨주고, 간접 연산자(*) 를 이용하여 주소 값이 가리키는 값을 읽거나 저장한다.

-> 예제 10-5. 인자 전달방법
#include <stdio.h>

void CountIncrement1(int n);  // 값을 전달.
void CountIncrement2(int* n);  // 주소를 전달.

int main(void)
{
	int a = 10;
	printf("a의 초깃값 : %d\n", a);

	CountIncrement1(a);
	printf("CountIncrement1 함수 실행 후 a의 값 : %d\n", a);

	CountIncrement2(&a);
	printf("CountIncrement2 함수 실행 후 a의 값 : %d\n", a);

	return 0;
}

void CountIncrement1(int n)
	{
		n++;
	}
void CountIncrement2(int* n)
{
	(*n)++;
}

이 때 CountIncrement1(int n)의 경우는 CountIncrement1 함수 내부에서만 값이 바뀌게 되어 main()함수의 a의 값이 바뀌지 않아 10이 출력된다.
그러나 CountIncrement2(int* n)의 경우에는 *n이 main()함수에 있는 변수 a의 주소값을 가리키기 때문에, a의 값이 중가하여 11이 출력된다.
-> 이때 CountIncrement2(int* n)함수에서 *n의 값을 증가시킬 때 (*n)++를 사용했는데 *n++를 사용하면 원하는 값이 나오지 않는다. 
   왜냐하면 *n++는 n의 값을 1만큼 증가시키는 것이 아니라, n++가 가리키고 있는 변수의 주소가 가리키고 있는 값을 의미하기 때문이다.

03. 포인터와 배열
-> 배열을 이용하여 포인터를 초기화하는 방법
  1). 배열 첨자 이용
    : int a[4] = {10, 20, 30, 40}
      int *p
      p = &a[0]

  2). 배열명 이용
     : p = a
-> 여기서 포인터 p는 포인터 변수이고, a는 포인터 상수를 의미한다. 즉 p가 가리키고 있는 것은 a[0]의 주소값이다.
-> 위의 예시를 기반으로, 배열 a의 주소를 표현하는 방법은 다음과 같다.
  1). 방법 1: &a[0], &a[1], &a[2], &a[3]
  2). 방법 2: a, a+1, a+2, a+3
  3). 방법 3: p, p+1, p+2, p+3

-> 위의 예시를 기반으로, 배열 a의 값을 표현하는 방법은 다음과 같다.
  1). 방법 1: a[0], a[1], a[2], a[3]
  2). 방법 2: *a, *(a+1), *(a+2), *(a+3)

   
