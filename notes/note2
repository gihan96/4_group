연습문제 1. 
식별자 작성 규칙은 다음과 같다.
1). 영문 대문자와 소문자(A~Z, a~z), 숫자(0~9), 밑줄(_)을 포함한 63개의 문자로만 구성할 수 있다.
2). 첫 글자로 숫자를 사용할 수 없다.
3). 대문자와 소문자를 구별하며, 키워드는 사용할 수 없다. 
  
위의 규칙에 따라 식별자 이름의 올바른 예와 잘못된 예를 구분하면
① 올바른 예: _number, define, INTI,  
② 잘못된 예: 9values, sizeof, _%_save, extern –age				     
로 구분 할 수 있다.

※ 잘못된 예시인 이유
-> 9values: 첫 글자가 숫자이다.
-> sizeof: C언어의 키워드 sizeof이기 때문이다.
-> _%_save: 특수문자 %가 사용되었다.
-> extern: C언어의 키워드 extern이기 때문이다.
-> -age: -는 식별자로 사용될 수 없다.


연습문제 2. 
2 – 1. 자료형 char는 1바이트의 크기를 가지면 범위는 –127~127이다. 
그래서 그 이상의 숫자 129를 넣었을 경우 지정된 범위를 초과하기 때문에 오버플로우가 발생해 다른 값이 저장된다. 
따라서 이 문제를 해결하기 위해서는 char앞에 unsigned를 붙여 범위를 0~255인 상태로 만들어 주거나 short나 int와 같이 2바이트 이상의 데이터를 저장하는 자료형으로 수정하면 된다.

2 – 2. 
-> 5번째 줄을 보면 number라는 변수를 보면 int 앞에 상수를 만드는 const가 들어있다. 
그렇기 때문에 8번째 줄에 있는 number의 값을 30으로 바꾸게 되면 오류가 발생한다.
만약 number의 값을 바꿔야 한다면 const를 지우면 number를 상수에서 변수로 바꿀 수 있어서, number의 값을 바꿀 수 있다.
-> 변수 length와 area의 자료형 short는 2바이트의 데이터를 저장하는 정수형 변수이다. 
그런데 length에 저장된 값은 5.56은 실수이다. 
그래서 만약 이 상태로 계산할 경우 0.000000이라는 값으로 나오는 오류가 발생한다. 
따라서 length와 area 앞에 short가 아닌 실수형 자료형인 float나 double을 사용해야 올바른 값으로 계산할 수 있다.


묵시적 형변환 
char -> short -> int -> unsigned -> long -> float ->　double 순으로 이루어지는 이유?
-> 1). 각 자료형 마다 사용되는 메모리의 크기가 서로 다르다. 그렇기 때문에 크기가 다른 두 자료형이 있을 때, 크기가 큰 자료형으로 자동으로 변환되어 계산된다. 
만약 그 반대가 되면, 저장된 변수의 값이 해당 자료형의 데이터의 허용범위를 초과하는 값, 즉 오버플로우가 발생할 수 있다.
  2). int와 float의 경우 같은 4바이트의 데이터를 저장하는 자료형이다. 그러나 int의 경우는 정수만 나타낼 수 있고, float의 경우는 정수를 포함한 실수 전체를 저장할 수 있다. 
그래서 만약 float가 아닌 int로 변환되어 계산할 경우, 정수가 아닌 부분의 실수는 계산이 되어지지 않는 문제점이 발생한다. 
따라서 같은 양의 데이터를 저장하는 두 개의 자료형이 있을 때, 정수형보다 실수형으로 형변환이 이루어 진다.
