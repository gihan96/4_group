* C언어를 이용할 때 증감, 조건, 비트, 비트논리, 비트이동 연산자를 잘 알아야 한다. 

* 산술 연산자
-> 증감 연산자: p. 101의 표 4 – 4 증감 연산자의 사용 예. 왜 그렇게 나오는가?
1). b = ++a: a에 1을 더한 후 그 값을 b에 대입하므로 a = 11, b = 11로 나온다.
2). b = --a: a에 1을 뺀 후 그 값을 b에 대입하므로 a = 9, b = 9로 나온다.
3). b = a++: a의 값을 b에 대입 후 a에 1을 더하므로, a = 11, b = 10로 나온다.
4). b = a--: a의 값을 b에 대입 후 a에 1을 빼므로, a = 9, b = 10으로 나온다.

-> p.102 혼자 해 보기 
1). 줄 8: b의 값을 a에 대입 후 b에 1을 더함.(a = 10, b = 11)
2). 줄 10: a에 1을 더한 후 그 값을 d에 대입(a = 11, d = 11)
3). 줄 11: a = 11, b = 11, d = 11 출력
4). 줄 13: d에 1을 더한 후 b와 d를 더한 값을 a에 대입한다.(a = 23, b = 11, d = 12)
5). 줄 15: a = 23, b = 11, d = 12 출력

* 이항 연산자
-> 나눗셈의 경우 나머지는 없어지고, 몫의 값만 저장된다.
-> 나머지 연산의 경우, 몫의 값은 없어지고 나머지값만 저장된다.

-> p.103 예제 4 –3
1) 줄 8: a, b, d는 정수이므로, d = a / b => d의 값에 20 / 3 = 몫: 6, 나머지: 2, 몫의 값인 6만 저장됨.
2). 줄 9: d의 값 6 출력
3). 줄 11: a, c, e는 정수이므로, e = a % c => 20 / 7 = 몫: 2, 나머지 6, 나머지 값인 6만 저장됨   
4). 줄 12: e의 값 6 출력
5). 줄 14: c는 정수, f, g는 실수이므로, g = f / c => 15.0 / 7의 값을 묵시적 형변환으로 인해 실수로 적용되어 g의 값에 실수 2.142857이 저장됨.
6). 줄 15: g의 값 2.142857 출력
* 관계 연산자
-> 예제 4 – 5
1). 줄 9: 점수 입력.
2). 줄 11: grade는 score 변수보다 크거나 같음.
3). 줄 13 만약 변수 grade 가 참일 때(grade == 1은 grade의 값이 참을 의미한다.) 줄 14 출력.
4). 줄 15. 만약 grade가 거짓일 때 줄 16을 출력.
=> 여기서 줄 10의 grade = score >= 90; 이 문제없이 돌아가는 이유에 대해서는 p.124에 있는 연산자 우선순위를 참고함.

*논리 연산자

|X|Y|AND|OR|NOT(!X)|
|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|
|1|0|0|1|0|
|0|1|0|1|1|
|1|1|1|1|0|

-> 예제 4 – 7
1). 줄 5: 정수 a = 0, b = 1, c = 1이 저장된다
2). 줄 7: AND와 OR가 동시에 있을 경우 AND 연산자를 우선 수행한다. 따라서 1 AND 1 OR 0 = 1 OR 1 = 1. 즉 1이 출력된다.
3). 줄 8: 1 AND 0 OR 1 = 0 OR 1 = 1. 즉 1이 출력된다.
4). 줄 9: 1 AND 0 OR 0 = 0 OR 0 = 0. 즉 0이 출력된다.
5). 줄 12: b AND a OR a AND c = 1 AND 0 OR 0 AND 1 = 0 OR 0 = 0. 즉 0이 출력된다.
6). 줄 12 연산자 우선순위에 의해 ()가 우선순위가 가장 높기 때문에, (b AND a) OR (a AND c) = (1 AND 0) OR (0 AND 1) = 0 OR 0 = 0. 즉 0이 출력된다.

-> 예제 4 – 8
1). 줄 5: 정수 a = 0, b = 1, c = 1이 저장된다.
2). 줄 7: 연산자 우선순위에 의해 관계 연산자(<, >)의 우선순위가 논리 연산자보다 높기 때문에, a < b AND c > a의 결과값은 0 < 1 AND 1 > 0 => 0 1 AND 1 = 1 즉 1이 출력된다.
3). 줄 8: a > b AND c > a =>　0＞１AND 1 > 0 = > 0 AND 1 = 0. 즉 0이 출력된다.
4). 줄 9: a > b OR c > a => 0 > 1 OR 1 > 0 => 0 OR 1 = 1. 즉 1이 출력된다.
5). 줄 12: (a > b) OR (c > a) => (0 > 1) OR (1 > 0) => 0 OR 1 = 1. 즉 1이 출력된다.

* 비트 연산자
-> 10진수 1~15를 16진수와 2진수 표현 및 16진수(역순)와의 논리연산

|10진수|16진수|2진수 |16진수(역순)|AND |OR|XOR|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|0x01|0001|0x0F|0001|1111|1110|
|2|0x02|0010|0x0E|0010|1110|1100|
|3|0x03|0011|0x0D|0001|1111|1110|
|4|0x04|0100|0x0C|0100|1100|1000|
|5|0x05|0101|0x0B|0001|1111|1110|
|6|0x06|0110|0x0A|0010|1110|1100|
|7|0x07|0111|0x09|0001|1111|1110|
|8|0x08|1000|0x08|1000|1000|0000|
|9|0x09|1001|0x07|0001|1111|1110|
|10|0x0A|1010|0x06|0010|1110|1100|
|11|0x0B|1011|0x05|0001|1111|1110|
|12|0x0C|1100|0x04|0100|1100|1000|
|13|0x0D|1101|0x03|0001|1111|1110|
|14|0x0E|1110|0x02|0010|1110|1100|
|15|0x0F|1111|0x01|0001|1111|1110|

-> 예제 4 – 9
1) 정수형 char는 1바이트의 데이터를 저장하는 변수이다.
   -> (signed) char = -128 ~ 127
   -> unsigned char = 0 ~ 255
따라서 일반 정수형처럼 scanf에 변수를 입력시 %d, %f 등을 사용하면 예외처리라고 나오는 오류가 발생한다. 따라서 char 형 변수를 저장 및 표현 하고자 할때는
  -> (signed) char = %hhd, 또는 %c
  -> unsigned char = %hhu 또는 %c
형식으로 저장해야 한다. 
2). 줄 6: lastmask = 1 => 변수 lastmask는 2진수 0000 0001로 표현되어 저장되어 지기도 한다..
3). 줄 7: firstmask = 128 => 변수 firstmask는 2진수 1000 0000로 표현되어 저장되어 지기도 한다.
3) 줄 12~16: 줄 12에서 임의의 정수를 입력하면 줄 14와 15에서는 줄 12에서 입력한 값에 줄 6, 7의 lastmask와 firstmask의 값을 비트연산자 &(AND)를 적용시킨다.
예를 들어 입력한 값이 5일 경우 5의 2진수는 0000 0101 일 때. 
5). 줄 14: 5(0000 0101) & 128(1000 0000) > 127 => 0(0000 0000) > 127의 값은 0이 되므로 0이 출력된다.
6). 줄 16: 5(0000 0101) & 1(0000 0001) => 1(0000 0001) 즉 1이 출력된다.
7). 줄 14에서 (input & firstmask) > 127로 되어 있는 이유는 input의 첫 번째 비트(0 또는 1)를 출력해야 하는데, firstmask의 값은 정수 128(1000 0000)로 저장되어 있다. 그래서 만약에 “> 127” 없이 (input & firstmask)으로만 될 경우, 정수 0 또는 128이 출력된다. 따라서 (input & firstmask)에 “> 127”을 붙여 만약 input & firstmask)의 값이 128이 될 경우 128 > 127 => 1(참)의 값으로 계산되어 출력할 수 있다.

*기타 연산자
-> 콤마(,)연산자: 콤마연산자는 연산자 중 우선순위가 가방 낮으며 왼쪽에서 오른쪽으로 수행한다.
1) 예 1: x = 3 + 4, 5 – 10의 경우 x의 값은 3 + 4 = 7의 값이 저장되어 출력된다.
2) 예 2: x = (3 + 4, 5 – 10)의 경우 ()가 있기 때문에 왼쪽에서 오른쪽으로 차례대로 수행해야 한다. 따라서 x = 3 + 4 = 7의 값을 저장 후, x = 5 – 10 = -5의 값이 저장되어 출력된다.

-> 예제 4 –12
1). 줄 7: x = (y = 5, y + 10)의 경우 콤마 연산자 양 끝에 ()가 있으므로 y = 5, y + 10을 차례대로 수행하면 
① x = y = 5(y = 5 저장)
② x = y + 10 = 5 + 10 = 15의 순서대로 진행되어진다.
따라서 x = 15, y = 5의 값이 출력되어 진다.

-> 축약 연산자

-> 예제 4 – 13
1). 줄 5: 정수형 변수 a에 10을 저장.
2). 줄 8: a +=5 => a에 5를 더한 값을 a에 대입해 준다.(a = 15)
3). 줄 9: a의 값은 15로 출력된다.
4). 줄 11: a = 10; a -= 5 + 2; => a가 10일 때 5 + 2의 값 7을 a에서 뺀 값을 a에 대입해준다.
5). 줄 12 a는 10 - (5 + 2) = 10 – 7 = 3이 출력된다.
6). 줄 14: a = 10; a *=2 + 5; => a의 값이 10일 때 2+5 = 7의 값에 a를 곱한 후 그 값을 a에 대입해 준다.
7). 줄 15: a는 10 * (2 + 5) = 10 * 7 = 70이 출력된다.

-> sizeof 연산자: 어떤 변수나 자료형의 크기를 알고 싶을 때 사용하는 함수이다. 만약 sizeof 연산자를 사용하고 싶다면 반드시 괄호를 넣어 주어야 한다. 예를 들어 int의 크기를 알고 싶을 때 sizeof(int)로 해야 한다. 하지만 변수에 사용할 때는 괄호를 생략할 수 있다. 
