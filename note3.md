* C언어를 이용할 때 증감, 조건, 비트, 비트논리, 비트이동 연산자를 잘 알아야 한다. 

* 산술 연산자
-> 증감 연산자: p. 101의 표 4 – 4 증감 연산자의 사용 예. 왜 그렇게 나오는가?
1). b = ++a: a에 1을 더한 후 그 값을 b에 대입하므로 a = 11, b = 11로 나온다.
2). b = --a: a에 1을 뺀 후 그 값을 b에 대입하므로 a = 9, b = 9로 나온다.
3). b = a++: a의 값을 b에 대입 후 a에 1을 더하므로, a = 11, b = 10로 나온다.
4). b = a--: a의 값을 b에 대입 후 a에 1을 빼므로, a = 9, b = 10으로 나온다.

-> p.102 혼자 해 보기 
1). 줄 8: b의 값을 a에 대입 후 b에 1을 더함.(a = 10, b = 11)
2). 줄 10: a에 1을 더한 후 그 값을 d에 대입(a = 11, d = 11)
3). 줄 11: a = 11, b = 11, d = 11 출력
4). 줄 13: d에 1을 더한 후 b와 d를 더한 값을 a에 대입한다.(a = 23, b = 11, d = 12)
5). 줄 15: a = 23, b = 11, d = 12 출력

* 이항 연산자
-> 나눗셈의 경우 나머지는 없어지고, 몫의 값만 저장된다.
-> 나머지 연산의 경우, 몫의 값은 없어지고 나머지값만 저장된다.

-> p.103 예제 4 –3
1) 줄 8: a, b, d는 정수이므로, d = a / b => d의 값에 20 / 3 = 몫: 6, 나머지: 2, 몫의 값인 6만 저장됨.
2). 줄 9: d의 값 6 출력
3). 줄 11: a, c, e는 정수이므로, e = a % c => 20 / 7 = 몫: 2, 나머지 6, 나머지 값인 6만 저장됨   
4). 줄 12: e의 값 6 출력
5). 줄 14: c는 정수, f, g는 실수이므로, g = f / c => 15.0 / 7의 값을 묵시적 형변환으로 인해 실수로 적용되어 g의 값에 실수 2.142857이 저장됨.
6). 줄 15: g의 값 2.142857 출력
* 관계 연산자
-> 예제 4 – 5
1). 줄 9: 점수 입력.
2). 줄 11: grade는 score 변수보다 크거나 같음.
3). 줄 13 만약 변수 grade 가 참일 때(grade == 1은 grade의 값이 참을 의미한다.) 줄 14 출력.
4). 줄 15. 만약 grade가 거짓일 때 줄 16을 출력.
=> 여기서 줄 10의 grade = score >= 90; 이 문제없이 돌아가는 이유에 대해서는 p.124에 있는 연산자 우선순위를 참고함.

*논리 연산자

|X|Y|AND|OR|NOT(!X)|
|:---:|:---:|:---:|:---:|:---:|
|0|0|0|0|1|
|1|0|0|1|0|
|0|1|0|1|1|
|1|1|1|1|0|

-> 예제 4 – 7
1). 줄 5: 정수 a = 0, b = 1, c = 1이 저장된다
2). 줄 7: AND와 OR가 동시에 있을 경우 AND 연산자를 우선 수행한다. 따라서 1 AND 1 OR 0 = 1 OR 1 = 1. 즉 1이 출력된다.
3). 줄 8: 1 AND 0 OR 1 = 0 OR 1 = 1. 즉 1이 출력된다.
4). 줄 9: 1 AND 0 OR 0 = 0 OR 0 = 0. 즉 0이 출력된다.
5). 줄 12: b AND a OR a AND c = 1 AND 0 OR 0 AND 1 = 0 OR 0 = 0. 즉 0이 출력된다.
6). 줄 12 연산자 우선순위에 의해 ()가 우선순위가 가장 높기 때문에, (b AND a) OR (a AND c) = (1 AND 0) OR (0 AND 1) = 0 OR 0 = 0. 즉 0이 출력된다.

-> 예제 4 – 8
1). 줄 5: 정수 a = 0, b = 1, c = 1이 저장된다.
2). 줄 7: 연산자 우선순위에 의해 관계 연산자(<, >)의 우선순위가 논리 연산자보다 높기 때문에, a < b AND c > a의 결과값은 0 < 1 AND 1 > 0 => 0 1 AND 1 = 1 즉 1이 출력된다.
3). 줄 8: a > b AND c > a =>　0＞１AND 1 > 0 = > 0 AND 1 = 0. 즉 0이 출력된다.
4). 줄 9: a > b OR c > a => 0 > 1 OR 1 > 0 => 0 OR 1 = 1. 즉 1이 출력된다.
5). 줄 12: (a > b) OR (c > a) => (0 > 1) OR (1 > 0) => 0 OR 1 = 1. 즉 1이 출력된다.

* 비트 연산자
-> 10진수 1~15를 16진수와 2진수 표현 및 16진수(역순)와의 논리연산

|10진수|16진수|2진수 |16진수(역순)|AND |OR|XOR|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1|0x01|0001|0x0F|0001|1111|1110|
|2|0x02|0010|0x0E|0010|1110|1100|
|3|0x03|0011|0x0D|0001|1111|1110|
|4|0x04|0100|0x0C|0100|1100|1000|
|5|0x05|0101|0x0B|0001|1111|1110|
|6|0x06|0110|0x0A|0010|1110|1100|
|7|0x07|0111|0x09|0001|1111|1110|
|8|0x08|1000|0x08|1000|1000|0000|
|9|0x09|1001|0x07|0001|1111|1110|
|10|0x0A|1010|0x06|0010|1110|1100|
|11|0x0B|1011|0x05|0001|1111|1110|
|12|0x0C|1100|0x04|0100|1100|1000|
|13|0x0D|1101|0x03|0001|1111|1110|
|14|0x0E|1110|0x02|0010|1110|1100|
|15|0x0F|1111|0x01|0001|1111|1110|

